<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CornerCat</title>
  <icon>https://www.gravatar.com/avatar/724a74253aeb6df475499280cf4a015b</icon>
  <subtitle>不喜欢刺眼的阳光！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://craneyuan.github.io/"/>
  <updated>2019-03-03T07:44:02.533Z</updated>
  <id>https://craneyuan.github.io/</id>
  
  <author>
    <name>craneyuan</name>
    <email>eXVhbnhpbmduZXB1K2Jsb2dAZ21haWwuY29t</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作生活中常用工具汇总</title>
    <link href="https://craneyuan.github.io/2019/01/31/tools-choose/"/>
    <id>https://craneyuan.github.io/2019/01/31/tools-choose/</id>
    <published>2019-01-31T11:15:42.000Z</published>
    <updated>2019-03-03T07:44:02.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年的总结在本地的笔记本中躺着呢，就不公开了。2019年的也很简单，也就不公开了。</p><p>最近博客更新的频率降了下来了，不是没有什么东西想去分享，只是总怕自己分享的观点有问题、误人子弟了。想起之前写的一些技术文章，确实是有问题的，时效性太强，可能之前这种观点是合理的，过了一段时间就变得不合理了；这也是本人最近不太愿意更新博客的原因之一。其次，就是人变懒了，没有上学期间那么勤快了，实在是惭愧啊！！！</p><p>这篇文章主要分享一些本人平时工作生活中常用的工具。不知道大家会不会遇到这样的情景，有很多同类型的工具都挺不错，难以选择用哪一个，这时候本人会参考下面这几个对比网站来进行抉择（有得选择代表自由，自由的代价就是你得做出选择，哈哈）</p><ul><li><a href="https://alternativeto.net/" target="_blank" rel="noopener">https://alternativeto.net/</a></li><li><a href="https://www.producthunt.com/" target="_blank" rel="noopener">https://www.producthunt.com/</a></li></ul><h2 id="Google-Chrome-插件篇"><a href="#Google-Chrome-插件篇" class="headerlink" title="Google Chrome 插件篇"></a>Google Chrome 插件篇</h2><ul><li>Decentraleyes 网页加速插件 | 预先缓存了一些第三方库文件到本地</li><li>Extension Manager 插件管理器</li><li>OneTab 标签页管理工具</li><li>Proxy SwitchyOmega 代理切换工具</li><li>Privacy Badger 隐私保护工具</li><li>Raindrop 书签同步工具</li><li>Wayback Machine 网页时光机工具</li><li>Tampermonkey 脚本管理器</li></ul><h2 id="编辑器篇"><a href="#编辑器篇" class="headerlink" title="编辑器篇"></a>编辑器篇</h2><ul><li>Simplenote 支持 markdown 的一款比较干净的多端笔记工具</li><li>MWeb 一款还不错的 Mac 下的笔记工具</li><li>Notion 这个笔记工具很炫丽，本人目前正在探索中。这里有篇不错的介绍文章：<a href="https://sspai.com/post/39694" target="_blank" rel="noopener">Notion：重新定义数字笔记</a> | 感兴趣的朋友可以注册试试 <a href="https://www.notion.so/?r=070970cf5ce04d70ae0dfe9b4ad25f99" target="_blank" rel="noopener">邀请码</a></li></ul><h2 id="杂项篇"><a href="#杂项篇" class="headerlink" title="杂项篇"></a>杂项篇</h2><ul><li>Alfred 功能极其强大，workflow 很不错</li><li>KeepPassXC 一款不错的本地密码管理工具，配合浏览器插件一起使用更方便</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/nikitavoloboev/my-mac-os" target="_blank" rel="noopener">My wonderful world of macOS</a></li></ul>]]></content>
    
    <summary type="html">
    
      汇总一些本人常用的工具，对抗脱发带来的遗忘QAQ。
    
    </summary>
    
      <category term="工具" scheme="https://craneyuan.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Data JPA vs Hibernate JPA vs JPA</title>
    <link href="https://craneyuan.github.io/2018/07/31/jpa/"/>
    <id>https://craneyuan.github.io/2018/07/31/jpa/</id>
    <published>2018-07-30T16:02:03.000Z</published>
    <updated>2019-03-03T15:02:14.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从文章的标题，就可以清晰地了解到，本文是来辨析三个容易将新手弄糊涂的技术名词。如果，你一眼看过去就知道这三个名词的区别及关系，那么，这篇文章你可以不用继续读下去了；除非，你是想要看看我有什么解释的不对，来纠错的（来找茬，哈哈），也欢迎留言。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>JPA（Java Persistence API，Java持久化API），它是一个关于如何处理对象关系映射（object-relational mappings）的规范；即，定义了映射Java中的Object到关系数据库Table的标准流程。</li><li>Hibernate JPA，它实现了JPA规范，是JPA规范的厂商（想想JDBC规范和MySQL数据库厂商的关系，JPA和Hibernate也是这么一种关系）。<blockquote><p>除了Hibernate这个厂商，EclipseLink也是一个比较流行的JPA厂商。</p></blockquote></li><li>Spring Data JPA，它是JPA规范的一个数据访问抽象；Spring Data旨在提供一种一致的数据访问模型，用于访问来自不同存储类型的数据。</li></ul><h2 id="JPA-背景"><a href="#JPA-背景" class="headerlink" title="JPA 背景"></a>JPA 背景</h2><p>在引入EJB 3.0规范之前，许多企业级Java开发人员使用由持久化框架（例如Hibernate）或数据访问对象（DAO）提供的轻量级持久化对象，来代替实体bean（EJB的一种）。 这是因为在以前的EJB规范中，实体bean需要太多复杂的代码和繁重的资源占用，并且由于bean和DAO对象或持久化框架之间的源代码中的互连和依赖性，使得它们只能在Java EE应用程序服务器中使用。 因此，最初在第三方持久性框架中提供的许多功能都被合并到Java Persistence API中，并且从2006年开始，像Hibernate（版本3.2）和TopLink Essentials这样的项目已经实现Java Persistence API规范。</p><h2 id="JPA-编年史"><a href="#JPA-编年史" class="headerlink" title="JPA 编年史"></a>JPA 编年史</h2><ul><li>2006年5月， JPA 1.0 规范作为 JCP JSR 220 的一部分最终被发布。</li><li>2009年12月，JPA 2.0 规范发布（JSR 317，Java EE 6 平台，依赖于 JPA 2.0。） </li><li>2013年4月， JPA 2.1 规范发布（JSR 338，Java EE 7 平台，依赖于 JPA 2.1。）</li><li>2017年6月， JPA 2.2 规范发布（JSR 338）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank" rel="noopener">Java Persistence API，维基百科定义</a></li><li><a href="https://spring.io/projects/spring-data-jpa#overview" target="_blank" rel="noopener">Spring Data JPA，Spring官方介绍</a></li><li><a href="https://stackoverflow.com/questions/23862994/what-is-the-difference-between-hibernate-and-spring-data-jpa" target="_blank" rel="noopener">What is the difference between Hibernate and Spring Data JPA</a></li><li><a href="http://www.infoq.com/cn/news/2018/01/improvements-jpa-22" target="_blank" rel="noopener">JPA 2.2改进了易用性</a></li><li><a href="https://github.com/javaee/jpa-spec" target="_blank" rel="noopener">Java Persistence API specification，官方GitHub存档</a></li><li><a href="http://www.in28minutes.com/jpa-hibernate-tutorial-for-beginners" target="_blank" rel="noopener">JPA and Hibernate in 10 Steps with Spring Boot and H2</a></li><li><a href="https://www.cnblogs.com/zhujiabin/p/5861319.html" target="_blank" rel="noopener">JPA与Hibernate的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      JPA 规范辨析。
    
    </summary>
    
      <category term="规范" scheme="https://craneyuan.github.io/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="java" scheme="https://craneyuan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java 第三版》新条目介绍</title>
    <link href="https://craneyuan.github.io/2018/06/03/effective-java-3e-new-items/"/>
    <id>https://craneyuan.github.io/2018/06/03/effective-java-3e-new-items/</id>
    <published>2018-06-03T14:42:13.000Z</published>
    <updated>2019-03-03T14:15:56.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从去年的3月份起我就在开始读《Effective Java 第二版》，当然，我读的是中文版的；可能是我理解能力还不行，对于书中的内容总是感觉理解困难；就拿第一章的内容「创建和销毁对象」来说吧，这是我读的次数最多的一章，想必原因大家也是明白的，每次我读不下去的时候，我就从头开始读，所以，现在我对这本书的第一章是最为熟悉的了。后来，有一次我上网看到有网友说这本书确实和绝大部分的翻译书籍一样，对于有些原文中的内容翻译的不是很流畅，所以会导致阅读的人感觉难以理解；于是，我就斗胆下了本英文的原版来对照着来看，发现确实这样理解起来就更容易了，所以最后花了一两个月的时间就把整本书给啃完了（好吧，真实的情况是，这段时间我参与了几个项目，编程经验也因此积累了不少，所以对于《Effective Java》这本书里推荐的「最佳实践」有了一点点的思考与理解。）</p><p>其实，到目前为止，我还是会时不时地拿起这本书来翻看，每次读都感觉与上一次不一样，这也许就是「温故知新」的意思吧。</p><h2 id="第三版新条目"><a href="#第三版新条目" class="headerlink" title="第三版新条目"></a>第三版新条目</h2><p>上面的絮絮叨叨大家可以不用关心，现在我就来介绍下第三版中加入的一些新的条目。</p><p>大家可以先看下下面这张图，有个整体的概念。<br><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1528040591/blog/15280317412354.jpg" alt="Java新特性对照表"></p><p>因为，《Effective Java 第二版》的原版是2008年出版的，至今（2018）年已经有十年了，Java 语言在这十年里发展的也比较迅速，Java语言中又有了些新的「最佳实践」了，幸好作者 Joshua Bloch 大叔重操旧笔为我们这群麻瓜带来了与时俱进地「最佳实践」。</p><p>这本书的原版是去年完稿的（2017年12月18号），作者正好补充了 Java 7、Java 8 和 Java 9 的一些「最佳实践」。另外，想必关注 Java 发展的麻瓜们已经了解到了 Java 之后的发版规则改了，<a href="http://www.infoq.com/cn/news/2017/09/Java6Month" target="_blank" rel="noopener">「Java版本发布周期变更为每六个月一次」</a>。是不是一下子觉得有点紧张了啊，其实也没什么好担心的，新特性的快速添加，对我们也是好事，可以减少一些低效的操作，使用新特性来解放生产力。</p><h3 id="Java-7-新特性"><a href="#Java-7-新特性" class="headerlink" title="Java 7 新特性"></a>Java 7 新特性</h3><ul><li>try-with-resources | 一种新的资源关闭处理方式</li><li>@SafeVarargs | 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告</li></ul><h3 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h3><ul><li>Lambdas | 引入函数式编程</li><li>Streams | 流式数据处理</li><li>Optionals | 参考Google的Guava类库实现的，用来解决空指针异常（NullPointerException，NPE）问题</li><li>Default methods in interfaces | 接口中可以有默认实现方法了</li></ul><h3 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h3><ul><li>Modules | 将 JDK 源代码重新组织为模块，对构建系统进行增强以使之支持对模块的编译，并在构建时强制对模块边界的应用</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章只是大概的介绍了下新添加的条目，具体的内容还是需要读者去阅读书籍去了解，本人目前也在阅读当中，后续有什么阅读感悟会及时与诸君分享的。那么，重要的问题来了，如何去获取这本书籍呢？因为中文翻译版本还没有那么快，那么，如果你对你的英文还感到有点自信，可以试试阅读英文原版。这里我就造福下大家了。下载地址：<a href="https://pan.baidu.com/s/1mTEtBGCSbZay9hy8k_rp-Q" target="_blank" rel="noopener">《Effective Java 第三版原版pdf》</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.infoq.com/cn/news/2018/02/JavaSupportJan18" target="_blank" rel="noopener">Oracle加快终止对以往Java版本的免费支持期</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/jdk-relnotes-index-2162236.html" target="_blank" rel="noopener">JDK 官方发版说明</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">JDK 8 新特性</a></li><li><a href="http://www.infoq.com/cn/news/2014/06/java8-learning-resources" target="_blank" rel="noopener">Java 8学习资料汇总</a></li><li><a href="https://pan.baidu.com/s/1mTEtBGCSbZay9hy8k_rp-Q" target="_blank" rel="noopener">《Effective Java 第三版原版pdf》</a></li></ul>]]></content>
    
    <summary type="html">
    
      介绍下《Effective Java 第三版》中新添加的条目。
    
    </summary>
    
      <category term="书籍" scheme="https://craneyuan.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="java" scheme="https://craneyuan.github.io/tags/java/"/>
    
      <category term="best-practice" scheme="https://craneyuan.github.io/tags/best-practice/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令小结</title>
    <link href="https://craneyuan.github.io/2018/05/07/git-flow-daily/"/>
    <id>https://craneyuan.github.io/2018/05/07/git-flow-daily/</id>
    <published>2018-05-07T13:32:33.000Z</published>
    <updated>2018-06-03T14:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阅读本篇文章需要读者了解 Git 的基本用法，如果你对 Git 完全不了解，请先行移步了解 Git 基础。<br>下面是几份本人觉得不错的 Git 入门教程，新手可以参考。</p><ul><li><a href="http://www.worldhello.net/gotgit/index.html" target="_blank" rel="noopener">《Git权威指南》| 国内一位大牛写的介绍 Git 用法的开源书籍，很详实</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">《Pro Git》| Git 官方社区编著的介绍 Git 用法的书籍</a></li></ul><h2 id="创建新分支，并且切换到新分支"><a href="#创建新分支，并且切换到新分支" class="headerlink" title="创建新分支，并且切换到新分支"></a>创建新分支，并且切换到新分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt; git checkout -b &lt;new_branch_name&gt; # 根据当前所在分支，创建新分支</span><span class="line">&gt; git checkout -b &lt;new_branch_name&gt; &lt;remote_name&gt;/&lt;remote_branch_name&gt; # 根据远程分支，创建分支</span></pre></td></tr></table></figure><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; git checkout &lt;branch_name&gt;</span></pre></td></tr></table></figure><h2 id="删除分支（本地-远程）"><a href="#删除分支（本地-远程）" class="headerlink" title="删除分支（本地/远程）"></a>删除分支（本地/远程）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt; git branch -d &lt;branch_name&gt; # 删除本地分支，当该分支没有关联远程分支或者关联的远程分支已经合并过，才会被允许删除</span><span class="line">&gt; git branch -D &lt;branch_name&gt; # 强制删除本地分支</span><span class="line">&gt; git push &lt;remote_name&gt; -d &lt;branch_name&gt; # 删除远程分支，git v1.7.0（2010年的版本）之后支持</span><span class="line">&gt; git push &lt;remote_name&gt; :&lt;branch_name&gt; # 删除远程分支，旧方式，新的也兼容这种</span></pre></td></tr></table></figure><h2 id="分支重命名"><a href="#分支重命名" class="headerlink" title="分支重命名"></a>分支重命名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt; # 重命名分支语法，-M 强制重命名，具体参见 git branch --help</span><span class="line">&gt; git branch -m &lt;newbranch&gt; # 重命名当前分支</span><span class="line">&gt; git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; # 重命名指定分支</span></pre></td></tr></table></figure><h2 id="重写-commit-信息"><a href="#重写-commit-信息" class="headerlink" title="重写 commit 信息"></a>重写 commit 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&gt; git rebase -i HEAD~&lt;num&gt; # 交互式地重写 commit 信息，将会用终端默认的编辑器进行操作</span><span class="line"></span><span class="line">下面的例子中，保存之后，将会使得[328f67b Update Rust]这一条合并到[f55b189 Update cookbook]</span><span class="line"></span><span class="line">pick 164bf1c Update cookbook</span><span class="line">pick f55b189 Update cookbook</span><span class="line">f 328f67b Update Rust</span><span class="line">pick 9834843 Update cookbook</span><span class="line"></span><span class="line"># Rebase 0b6762c..9834843 onto 0b6762c (4 commands)</span><span class="line">#</span><span class="line"># Commands:</span><span class="line"># p, pick = use commit</span><span class="line"># r, reword = use commit, but edit the commit message</span><span class="line"># e, edit = use commit, but stop for amending</span><span class="line"># s, squash = use commit, but meld into previous commit</span><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><span class="line"># x, exec = run command (the rest of the line) using shell</span><span class="line"># d, drop = remove commit</span><span class="line">#</span><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><span class="line">#</span><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><span class="line">#</span><span class="line"># However, if you remove everything, the rebase will be aborted.</span><span class="line">#</span><span class="line"># Note that empty commits are commented out</span></pre></td></tr></table></figure><blockquote><p>注意：最好不要重写公共的 commit 信息，这会给协作者带来不必要的困惑，推荐仅仅重写本地没有提交的 commit 信息。假设，你非得重写远程 commit 信息，请使用 git push -f 来强制更新远程代码。</p></blockquote><h2 id="从一个分支摘取-commit-到另一个分支"><a href="#从一个分支摘取-commit-到另一个分支" class="headerlink" title="从一个分支摘取 commit 到另一个分支"></a>从一个分支摘取 commit 到另一个分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt; git checkout &lt;target-branch&gt; # 切换到目标分支</span><span class="line">&gt; git cherry-pick &lt;commit_id&gt; # 将源分支的 commit 摘取到目的分支中</span></pre></td></tr></table></figure><h2 id="想要切换分支时，发现本地有一些写了一半的代码"><a href="#想要切换分支时，发现本地有一些写了一半的代码" class="headerlink" title="想要切换分支时，发现本地有一些写了一半的代码"></a>想要切换分支时，发现本地有一些写了一半的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; git stash # 将当前工作目录内容储藏</span><span class="line">&gt; git stash --include-untracked # 如果新添加了文件，将其一并储藏</span><span class="line">&gt; git stash pop # 将储藏的内容恢复到当前分支</span></pre></td></tr></table></figure><h2 id="回版、撤销commit"><a href="#回版、撤销commit" class="headerlink" title="回版、撤销commit"></a>回版、撤销commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; git reset --hard &lt;commit_id&gt; # 彻底回退到指定 commit</span></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1525708747/blog/fmxxmiw2k65o8y8k5qts.svg" alt="git 回版图解"></p><h2 id="丢弃本地新添加的文件"><a href="#丢弃本地新添加的文件" class="headerlink" title="丢弃本地新添加的文件"></a>丢弃本地新添加的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt; git clean --dry-run # 仅展示将会删除的本地 untracked files</span><span class="line">&gt; git clean # 添加 -f 选项，强制删除本地 untracked files</span></pre></td></tr></table></figure><h2 id="丢弃新的改动"><a href="#丢弃新的改动" class="headerlink" title="丢弃新的改动"></a>丢弃新的改动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; git checkout . # 注意末尾有个句号</span></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.worldhello.net/gotgit/index.html" target="_blank" rel="noopener">《Git权威指南》</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">《Pro Git》</a></li><li><a href="https://github.com/tiimgreen/github-cheat-sheet" target="_blank" rel="noopener">git cheatsheet</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解Git</a></li></ul>]]></content>
    
    <summary type="html">
    
      本人平时常用的 Git 命令小结。
    
    </summary>
    
      <category term="工具" scheme="https://craneyuan.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://craneyuan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>朝花夕拾━杂文选编[持续更新中...]</title>
    <link href="https://craneyuan.github.io/2018/04/22/awesome-meta-blog/"/>
    <id>https://craneyuan.github.io/2018/04/22/awesome-meta-blog/</id>
    <published>2018-04-22T14:52:11.000Z</published>
    <updated>2018-12-24T15:07:31.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>备注：在没有特殊标注的情况下，本文中的「译文」默认指的是「简体中文」，「原文」默认指的是「英文」。</p></blockquote><h2 id="提问的智慧（How-To-Ask-Questions-The-Smart-Way）"><a href="#提问的智慧（How-To-Ask-Questions-The-Smart-Way）" class="headerlink" title="提问的智慧（How To Ask Questions The Smart Way）"></a>提问的智慧（How To Ask Questions The Smart Way）</h2><blockquote><p>这篇文章的作者是<a href="https://zh.wikipedia.org/wiki/埃里克·雷蒙" target="_blank" rel="noopener">Eric S. Raymond</a> ，也就是《大教堂与市集》与《Unix编程艺术》的作者，这两本书的内容很精彩；这两本书对于希望了解开源文化、Unix文化的朋友来说值得一读。</p></blockquote><p>这篇文章教你如何正确地提出技术问题并获得满意的答案。这篇文章介绍了作者所认为一位发问者在发问之前应该要做好什么，而什么又是不该做的。作者认为这样能让问题容易令人理解，而且发问者自己也能学到较多东西。此文在网络上受到欢迎，被广泛转载而广为人知甚至奉为经典。著名的两个缩写STFW（Search the fxxking web）以及RTFM（Read the fxxking manual）就是出自本文。</p><ul><li>译文地址：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md" target="_blank" rel="noopener">提问的智慧</a></li><li>原文地址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">How To Ask Questions The Smart Way</a></li></ul><h2 id="如何有效地报告-Bug（How-to-Report-Bugs-Effectively）"><a href="#如何有效地报告-Bug（How-to-Report-Bugs-Effectively）" class="headerlink" title="如何有效地报告 Bug（How to Report Bugs Effectively）"></a>如何有效地报告 Bug（How to Report Bugs Effectively）</h2><blockquote><p>这篇文章的作者是<a href="https://www.chiark.greenend.org.uk/~sgtatham/" target="_blank" rel="noopener">Simon Tatham</a> ，他是一名专业的自由软件程序员。</p></blockquote><p>这篇文章教你如何有效地报告 Bug，在此我想一些处理过「工单」的开发人员应该能够明白一份「有效的 Bug 报告」对于解决问题是多么的重要。</p><ul><li>译文地址：<a href="https://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener">如何有效地报告 Bug</a></li><li>原文地址：<a href="https://www.chiark.greenend.org.uk/~sgtatham/bugs.html" target="_blank" rel="noopener">How to Report Bugs Effectively</a></li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      一些本人认为写得挺好的文章。
    
    </summary>
    
      <category term="杂项" scheme="https://craneyuan.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>关于日志的一些事，我想你应该了解</title>
    <link href="https://craneyuan.github.io/2018/03/29/thinking-of-log/"/>
    <id>https://craneyuan.github.io/2018/03/29/thinking-of-log/</id>
    <published>2018-03-29T15:12:21.000Z</published>
    <updated>2018-04-22T14:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志：每个软件工程师都应该知道的有关实时数据的统一概念"><a href="#日志：每个软件工程师都应该知道的有关实时数据的统一概念" class="headerlink" title="日志：每个软件工程师都应该知道的有关实时数据的统一概念"></a>日志：每个软件工程师都应该知道的有关实时数据的统一概念</h2><ul><li>原文链接：<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="noopener">The Log: What every software engineer should know about real-time data’s unifying abstraction</a> - <a href="http://www.linkedin.com/in/jaykreps" target="_blank" rel="noopener">Jay Kreps</a>，2013-12-16   </li><li>译文链接：<a href="https://github.com/crane-yuan/translations/tree/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="noopener">日志：每个软件工程师都应该知道的有关实时数据的统一概念</a></li></ul><p>为了方便阅读，我把它给转换成 PDF 格式了。</p><div class="row"><iframe src="https://drive.google.com/file/d/1mvjJZMReTYynW22ZRT0G_28mdR1GUtvN/preview" style="width:100%; height:550px"></iframe></div><h2 id="最佳日志实践（v2-0）"><a href="#最佳日志实践（v2-0）" class="headerlink" title="最佳日志实践（v2.0）"></a>最佳日志实践（v2.0）</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27363484" target="_blank" rel="noopener">最佳日志实践（v2.0）</a></li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      这篇文章收集了一些关于「日志」的资料。
    
    </summary>
    
      <category term="杂项" scheme="https://craneyuan.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo代码块前后空白行问题</title>
    <link href="https://craneyuan.github.io/2018/02/25/hexo-code-style-redundant-blank-solution/"/>
    <id>https://craneyuan.github.io/2018/02/25/hexo-code-style-redundant-blank-solution/</id>
    <published>2018-02-25T12:10:19.000Z</published>
    <updated>2019-03-03T14:51:22.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.找到<code>hexo-util/lib/highlight.js</code>文件<br>一般的路径为<code>${blog_path}/node_modules/hexo-util/lib/highlight.js</code><br>2.修改<code>highlight.js</code>文件中的代码<br>大概在<code>35~38</code>行<br>修改前：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span></pre></td><td class="code"><pre><span class="line">numbers += <span class="string">'&lt;div class="line"&gt;'</span> + (firstLine + i) + <span class="string">'&lt;/div&gt;'</span>;</span><span class="line">content += <span class="string">'&lt;div class="line'</span>;</span><span class="line">content += (mark.indexOf(firstLine + i) !== <span class="number">-1</span>) ? <span class="string">' marked'</span> : <span class="string">''</span>;</span><span class="line">content += <span class="string">'"&gt;'</span> + line + <span class="string">'&lt;/div&gt;'</span>;</span></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span></pre></td><td class="code"><pre><span class="line">numbers += <span class="string">'&lt;span class="line"&gt;'</span> + (firstLine + i) + <span class="string">'&lt;/span&gt;\n'</span>;</span><span class="line">content += <span class="string">'&lt;span class="line'</span>;</span><span class="line">content += (mark.indexOf(firstLine + i) !== <span class="number">-1</span>) ? <span class="string">' marked'</span> : <span class="string">''</span>;</span><span class="line">content += <span class="string">'"&gt;'</span> + line + <span class="string">'&lt;/span&gt;\n'</span>;</span></pre></td></tr></table></figure></p><blockquote><p>注意：主要是将<code>&lt;div&gt;</code>换成了<code>&lt;span&gt;</code></p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leokongwq.github.io/2016/10/14/hexo-codeblock-multiblank.html" target="_blank" rel="noopener">hexo代码块前后空白行问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了如何解决 Hexo 博文中代码段渲染之后出现大量空白行问题。
    
    </summary>
    
    
      <category term="hexo" scheme="https://craneyuan.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Boot的AOP处理自定义注解</title>
    <link href="https://craneyuan.github.io/2018/01/11/spring-boot-aop-custom-annotation/"/>
    <id>https://craneyuan.github.io/2018/01/11/spring-boot-aop-custom-annotation/</id>
    <published>2018-01-11T15:13:11.000Z</published>
    <updated>2019-03-03T14:44:47.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章<a href="https://craneyuan.github.io/2017/12/28/java-annotations-introduction/">Java 注解介绍</a>讲解了下Java注解的基本使用方式，并且通过自定义注解实现了一个简单的测试工具；本篇文章将介绍如何使用Spring Boot的AOP来简化处理自定义注解，并将通过实现一个简单的方法执行时间统计工具为样例来讲解这些内容。</p><h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><blockquote><p>面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。</p></blockquote><p>侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括元对象协议、主题（subject）、混入（mixin）和委托。</p><blockquote><p>注释：以上定义源自中文维基百科（如果访问不了，可以通过修改系统的hosts文件访问，<code>198.35.26.96 zh.wikipedia.org #中文维基百科</code>，只能帮到这了，如果还是上不了，那就麻烦上网搜索下怎么修改系统的hosts文件，不同系统下hosts文件位置不一样，如果是Linux或者Mac系统，我就直接告诉你吧，一般文件路径是<code>/etc/hosts</code>），AOP这个词的翻译有点和国内主流叫法不一致，国内主流都把AOP译做「面向切面编程」，大家不要拘泥于叫法，知道指的是同一个东西即可。</p></blockquote><p>估计，你看了这个定义也是懵的，如果想深入了解可以去知乎看看大佬们是如何掰扯的<a href="https://www.zhihu.com/question/24863332" target="_blank" rel="noopener">什么是面向切面编程AOP？</a>。我这边还是就直接上例子了吧。</p><h2 id="Spring-Boot的AOP环境准备"><a href="#Spring-Boot的AOP环境准备" class="headerlink" title="Spring Boot的AOP环境准备"></a>Spring Boot的AOP环境准备</h2><p>在<code>pom.xml</code>中引入相应的依赖模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Boot依赖包 --&gt;</span><span class="line">&lt;parent&gt;</span><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><span class="line">    &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;</span><span class="line">&lt;/parent&gt;</span><span class="line">&lt;dependencies&gt;</span><span class="line">    &lt;!-- AOP依赖模块 --&gt;</span><span class="line">    &lt;dependency&gt;</span><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><span class="line">        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><span class="line">    &lt;/dependency&gt;</span><span class="line">    &lt;!-- Web依赖模块 --&gt;</span><span class="line">    &lt;dependency&gt;</span><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><span class="line">    &lt;/dependency&gt;</span><span class="line">&lt;/dependencies&gt;</span></pre></td></tr></table></figure></p><h2 id="先实现一个简单的Web请求处理"><a href="#先实现一个简单的Web请求处理" class="headerlink" title="先实现一个简单的Web请求处理"></a>先实现一个简单的Web请求处理</h2><p>一个简单的处理Web请求的Controller。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.craneyuan.controller;</span><span class="line"></span><span class="line"><span class="keyword">import</span> com.craneyuan.service.IHelloWorldService;</span><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><span class="line"></span><span class="line"><span class="meta">@RestController</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><span class="line">    <span class="meta">@Autowired</span></span><span class="line">    <span class="keyword">private</span> IHelloWorldService helloWorldService;</span><span class="line"></span><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><span class="line">        <span class="keyword">return</span> helloWorldService.getHelloMessage(name);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure></p><p>一个简单的HelloWorld服务实现类，接口的定义我就不展示代码了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.craneyuan.service.impl;</span><span class="line"></span><span class="line"><span class="keyword">import</span> com.craneyuan.annotation.AnalysisActuator;</span><span class="line"><span class="keyword">import</span> com.craneyuan.service.IHelloWorldService;</span><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><span class="line"></span><span class="line"><span class="keyword">import</span> java.util.Optional;</span><span class="line"></span><span class="line"><span class="meta">@Service</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHelloMessage</span><span class="params">(String name)</span> </span>&#123;</span><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + Optional.ofNullable(name).orElse(<span class="string">"World!"</span>);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure></p><p>这样一个简单的Web服务就弄好了，你可以启动项目用<code>curl</code>命令调用试下，例如：<code>curl -XGET -i &quot;http://127.0.0.1:8080/hello?name=Java&quot;</code>，如果一切顺利的话，你将会得到类似下面这样的响应：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200</span><span class="line">Content-Type: text/plain;charset=UTF-8</span><span class="line">Content-Length: 11</span><span class="line">Date: Thu, 11 Jan 2018 09:45:38 GMT</span><span class="line"></span><span class="line">Hello Java</span></pre></td></tr></table></figure><h2 id="使用自定义注解来统计方法的执行时间"><a href="#使用自定义注解来统计方法的执行时间" class="headerlink" title="使用自定义注解来统计方法的执行时间"></a>使用自定义注解来统计方法的执行时间</h2><p>先定义一个用来统计方法执行时间的注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.craneyuan.annotation;</span><span class="line"></span><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><span class="line"></span><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnalysisActuator &#123;</span><span class="line">    <span class="function">String <span class="title">note</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure></p><p>然后定义一个切面，来处理刚刚定义的注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.craneyuan.aspect;</span><span class="line"></span><span class="line"><span class="keyword">import</span> com.craneyuan.annotation.AnalysisActuator;</span><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><span class="line"></span><span class="line"><span class="meta">@Aspect</span></span><span class="line"><span class="meta">@Component</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnalysisActuatorAspect</span> </span>&#123;</span><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(AnalysisActuatorAspect.class);</span><span class="line"></span><span class="line">    ThreadLocal&lt;Long&gt; beginTime = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><span class="line"></span><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(analysisActuator)"</span>)</span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceStatistics</span><span class="params">(AnalysisActuator analysisActuator)</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@Before</span>(<span class="string">"serviceStatistics(analysisActuator)"</span>)</span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, AnalysisActuator analysisActuator)</span> </span>&#123;</span><span class="line">        <span class="comment">// 记录请求到达时间</span></span><span class="line">        beginTime.set(System.currentTimeMillis());</span><span class="line">        log.info(<span class="string">"cy666 note:&#123;&#125;"</span>, analysisActuator.note());</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@After</span>(<span class="string">"serviceStatistics(analysisActuator)"</span>)</span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(AnalysisActuator analysisActuator)</span> </span>&#123;</span><span class="line">        log.info(<span class="string">"cy666 statistic time:&#123;&#125;, note:&#123;&#125;"</span>, System.currentTimeMillis() - beginTime.get(), analysisActuator.note());</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure></p><p>最后，只要在需要统计执行时间的方法上加上<code>@AnalysisActuator</code>注解就行了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.craneyuan.service.impl;</span><span class="line"></span><span class="line"><span class="keyword">import</span> com.craneyuan.annotation.AnalysisActuator;</span><span class="line"><span class="keyword">import</span> com.craneyuan.service.IHelloWorldService;</span><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><span class="line"></span><span class="line"><span class="keyword">import</span> java.util.Optional;</span><span class="line"></span><span class="line"><span class="meta">@Service</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloWorldService</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@AnalysisActuator</span>(note = <span class="string">"获取聊天信息方法"</span>)</span><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHelloMessage</span><span class="params">(String name)</span> </span>&#123;</span><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + Optional.ofNullable(name).orElse(<span class="string">"World!"</span>);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure></p><p>启动项目，用<code>curl</code>命令随便调用一下，如果顺利的话就可以观察到切面打印的日志了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span></pre></td><td class="code"><pre><span class="line">...</span><span class="line">cy666 statistic time:4, note:获取聊天信息方法</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-aop" target="_blank" rel="noopener">Spring Boot AOP Sample</a></li><li><a href="https://juejin.im/entry/5849175db123db0066048508" target="_blank" rel="noopener">Spring 中使用 AOP 切面解析处理自定义注解</a></li><li><a href="https://crane-yuan.github.io/2017/12/28/java-annotations-introduction/" target="_blank" rel="noopener">Java 注解介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了如何在 Spring Boot 中处理注解。
    
    </summary>
    
      <category term="Java平台" scheme="https://craneyuan.github.io/categories/Java%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="java" scheme="https://craneyuan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 注解介绍</title>
    <link href="https://craneyuan.github.io/2017/12/28/java-annotations-introduction/"/>
    <id>https://craneyuan.github.io/2017/12/28/java-annotations-introduction/</id>
    <published>2017-12-28T15:13:11.000Z</published>
    <updated>2019-03-03T14:49:48.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据（元数据 Metadata：描述数据的数据）。</p></blockquote><p>Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。 当然它也支持自定义Java标注</p><h2 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h2><p>Java 5 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><h3 id="作用在代码的注解（java-lang包中）"><a href="#作用在代码的注解（java-lang包中）" class="headerlink" title="作用在代码的注解（java.lang包中）"></a>作用在代码的注解（java.lang包中）</h3><ul><li>@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><h3 id="作用在其他注解的注解-或者说-元注解，java-lang-annotation包中"><a href="#作用在其他注解的注解-或者说-元注解，java-lang-annotation包中" class="headerlink" title="作用在其他注解的注解(或者说 元注解，java.lang.annotation包中)"></a>作用在其他注解的注解(或者说 元注解，java.lang.annotation包中)</h3><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><h3 id="从-Java-7-开始，额外添加了-3-个注解"><a href="#从-Java-7-开始，额外添加了-3-个注解" class="headerlink" title="从 Java 7 开始，额外添加了 3 个注解"></a>从 Java 7 开始，额外添加了 3 个注解</h3><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>注解可以用于许多不同的目的，最常见的是：</p><ul><li>给编译器提供信息：编译器可以使用注解来产生警告，甚至根据不同的规则产生错误。 这种用法的一个例子是Java 8 的 @FunctionalInterface 注解。 这使编译器验证注释类，并检查它是否是一个正确的功能接口。</li><li>文档化：软件应用程序可以使用注解来测量代码的质量，如FindBugs或PMD，或者像Jenkins，Jira或Teamcity一样自动生成报告。</li><li>代码生成：使用注解可以使用代码中存在的元数据信息自动生成代码或XML文件。 JAXB库就是一个很好的例子。</li><li>运行时处理：在运行时检查的注解可用于不同的目标，如单元测试（Junit），依赖注入（Spring），验证，日志记录（Log4J），数据访问（Hibernate）等。</li></ul><h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><p>讲个 <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/annotations.html" target="_blank" rel="noopener">Java 官方提供的例子</a>，用注解实现简单的测试框架。</p><h3 id="MyTest-注解"><a href="#MyTest-注解" class="headerlink" title="@MyTest 注解"></a>@MyTest 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><span class="line"></span><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="FooTest-测试类"><a href="#FooTest-测试类" class="headerlink" title="FooTest 测试类"></a>FooTest 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooTest</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@MyTest</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@MyTest</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Boom"</span>);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@MyTest</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m5</span><span class="params">()</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m6</span><span class="params">()</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@MyTest</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m7</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Crash"</span>);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m8</span><span class="params">()</span> </span>&#123;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="RunMyTests-测试执行类"><a href="#RunMyTests-测试执行类" class="headerlink" title="RunMyTests 测试执行类"></a>RunMyTests 测试执行类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><span class="line"></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunMyTests</span> </span>&#123;</span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><span class="line">        <span class="keyword">int</span> passed = <span class="number">0</span>;</span><span class="line">        <span class="keyword">int</span> failed = <span class="number">0</span>;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><span class="line">            System.out.println(<span class="string">"please give test class."</span>);</span><span class="line">            System.exit(<span class="number">1</span>);</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">for</span> (Method method : Class.forName(args[<span class="number">0</span>]).getMethods()) &#123;</span><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyTest.class)) &#123;</span><span class="line">                <span class="keyword">try</span> &#123;</span><span class="line">                    method.invoke(<span class="keyword">null</span>);</span><span class="line">                    passed++;</span><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><span class="line">                    System.out.printf(<span class="string">"Test %s failed: %s %n"</span>, method, ex.getCause());</span><span class="line">                    failed++;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">        System.out.printf(<span class="string">"Passed: %d, Failed %d%n"</span>, passed, failed);</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="编译、运行测试执行类"><a href="#编译、运行测试执行类" class="headerlink" title="编译、运行测试执行类"></a>编译、运行测试执行类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&gt; javac FooTest.java MyTest.java RunMyTests.java</span><span class="line">&gt; java RunMyTests FooTest</span><span class="line">Test public static void FooTest.m3() failed: java.lang.RuntimeException: Boom</span><span class="line">Test public static void FooTest.m7() failed: java.lang.RuntimeException: Crash</span><span class="line">Passed: 2, Failed 2</span></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.javacodegeeks.com/2014/11/java-annotations-tutorial.html" target="_blank" rel="noopener">Java Annotations Tutorial – The ULTIMATE Guide (PDF Download)</a></li><li><a href="https://www.jcp.org/aboutJava/communityprocess/final/jsr175/index.html" target="_blank" rel="noopener">JSR 175 A metadata facility for the Java programming Language</a></li><li><a href="https://jcp.org/en/jsr/detail?id=250" target="_blank" rel="noopener">JSR 250 Common Annotations for the Java Platform</a></li><li><a href="http://zhangchuzhao.site/2016/09/23/java-annotation/" target="_blank" rel="noopener">Java 注解深入理解</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/" target="_blank" rel="noopener">Lesson: Annotations</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了 Java 中的注解的基本概念及常见的应用场景。
    
    </summary>
    
      <category term="Java平台" scheme="https://craneyuan.github.io/categories/Java%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="java" scheme="https://craneyuan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Greasy Fork 用户脚本简介</title>
    <link href="https://craneyuan.github.io/2017/03/25/greasyfork-introduction/"/>
    <id>https://craneyuan.github.io/2017/03/25/greasyfork-introduction/</id>
    <published>2017-03-25T08:22:33.000Z</published>
    <updated>2019-03-03T14:52:29.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Greasy-Fork-简介"><a href="#Greasy-Fork-简介" class="headerlink" title="Greasy Fork 简介"></a><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork 简介</a></h2><blockquote><p>用户脚本为您增强对浏览体验的控制权。在安装之后，它们可自动为您访问的网站添加功能，或使其更加易用、更加清新。在 Greasy Fork 上的用户脚本是由其他用户编写并向全世界发表的，您可以免费和轻松地安装。</p></blockquote><h2 id="如何使用-Greasy-Fork"><a href="#如何使用-Greasy-Fork" class="headerlink" title="如何使用 Greasy Fork"></a>如何使用 Greasy Fork</h2><h3 id="第一步：安装一个用户脚本管理器"><a href="#第一步：安装一个用户脚本管理器" class="headerlink" title="第一步：安装一个用户脚本管理器"></a>第一步：安装一个用户脚本管理器</h3><p>要使用用户脚本，您首先需要安装一个用户脚本管理器。根据您使用的浏览器不同，可用的用户脚本管理器也有所不同。</p><ul><li><a href="http://tampermonkey.net/" target="_blank" rel="noopener">Tampermonkey</a>，支持Chrome, Firefox, Microsoft Edge, Safari, Opera Next, Maxthon</li><li><a href="https://addons.mozilla.org/firefox/addon/greasemonkey/" target="_blank" rel="noopener">Greasemonkey</a>，支持Firefox</li></ul><h3 id="第二步：安装一个用户脚本"><a href="#第二步：安装一个用户脚本" class="headerlink" title="第二步：安装一个用户脚本"></a>第二步：安装一个用户脚本</h3><p><a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">浏览此网站</a> 查找您想尝试的用户脚本。</p><p>在您找到想要的用户脚本后，点击用户脚本页面上绿色的安装按钮，您的用户脚本管理器将询问您是否安装。</p><h3 id="第三步：使用用户脚本"><a href="#第三步：使用用户脚本" class="headerlink" title="第三步：使用用户脚本"></a>第三步：使用用户脚本</h3><p>转至用户脚本适用的网站。它应该已自动启动和生效。在试用用户脚本后，您可以返回用户脚本页面，给用户脚本的作者留下反馈。</p><h2 id="「新浪微博一键清空」脚本分享"><a href="#「新浪微博一键清空」脚本分享" class="headerlink" title="「新浪微博一键清空」脚本分享"></a><a href="https://greasyfork.org/zh-CN/scripts/25697-新浪微博一键清空" target="_blank" rel="noopener">「新浪微博一键清空」</a>脚本分享</h2><p>清空您发过的所有微博，目前没有备份功能，慎用！</p><p>项目地址：<a href="https://github.com/crane-yuan/delmyweibo" target="_blank" rel="noopener">https://github.com/crane-yuan/delmyweibo</a></p><h3 id="演示动画"><a href="#演示动画" class="headerlink" title="演示动画"></a>演示动画</h3><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521870142/blog/qav3p4kc5nok6n6inj8s.gif" alt="删除微博脚本演示动画"></p>]]></content>
    
    <summary type="html">
    
      本文介绍了一款强大的浏览器增强插件 Greasy Fork，可以用来编写自定义 JavaScript 脚本来控制页面。
    
    </summary>
    
      <category term="杂项" scheme="https://craneyuan.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="plugin" scheme="https://craneyuan.github.io/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>中文文案排版指北</title>
    <link href="https://craneyuan.github.io/2017/03/15/chinese-copywriting-guidelines/"/>
    <id>https://craneyuan.github.io/2017/03/15/chinese-copywriting-guidelines/</id>
    <published>2017-03-15T15:32:33.000Z</published>
    <updated>2019-03-03T15:01:28.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉中，写个人博客也有一年多了。记得刚开始写博客时，内心总是很纠结，非常担心自己写得不好，给别人瞧着，被人骂，后来才明白写博客是一件只和自己有关的事。</p><p>虽然，写博客是一件个人的事，但是，一份好的排版也是对自己的一种负责任吧！</p><p>下面是我从GitHub上了解到的一份<a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">「中文文安排版指北」</a>，记录一下，以后希望都按照这个规范来排版，养成一个好的书写习惯。</p><hr><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p><p>与大家共勉之。」——<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></p><h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a href="#数字与单位之间需要增加空格" class="headerlink" title="数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。</p></blockquote><p>例外：度／百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p></blockquote><h3 id="ms-text-autospace-to-the-rescue"><a href="#ms-text-autospace-to-the-rescue" class="headerlink" title="-ms-text-autospace to the rescue?"></a><code>-ms-text-autospace</code> to the rescue?</h3><p>Microsoft 有个 <a href="http://msdn.microsoft.com/en-us/library/ie/ms531164(v=vs.85" target="_blank" rel="noopener"><code>-ms-text-autospace</code></a>.aspx) 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a href="#不重复使用标点符号" class="headerlink" title="不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="http://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2" target="_blank" rel="noopener">全角和半角</a>』。</p><h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!</p><p>嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这件蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这件蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其內容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其內容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其內容使用半角标点"></a>遇到完整的英文整句、特殊名词，其內容使用半角标点</h3><p>正确：</p><blockquote><p>乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，既：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a href="#简体中文使用直角引号" class="headerlink" title="简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>仓库</th><th>语言</th></tr></thead><tbody><tr><td><a href="https://github.com/vinta/paranoid-auto-spacing" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></td><td>JavaScript</td></tr><tr><td><a href="https://github.com/huei90/pangu.node" target="_blank" rel="noopener">huei90/pangu.node</a></td><td>Node.js</td></tr><tr><td><a href="https://github.com/huacnlee/auto-correct" target="_blank" rel="noopener">huacnlee/auto-correct</a></td><td>Ruby</td></tr><tr><td><a href="https://github.com/sparanoid/space-lover" target="_blank" rel="noopener">sparanoid/space-lover</a></td><td>PHP (WordPress)</td></tr><tr><td><a href="https://github.com/NauxLiu/auto-correct" target="_blank" rel="noopener">nauxliu/auto-correct</a></td><td>PHP</td></tr><tr><td><a href="https://github.com/hotoo/pangu.vim" target="_blank" rel="noopener">hotoo/pangu.vim</a></td><td>Vim</td></tr><tr><td><a href="https://github.com/sparanoid/grunt-auto-spacing" target="_blank" rel="noopener">sparanoid/grunt-auto-spacing</a></td><td>Node.js (Grunt)</td></tr><tr><td><a href="https://github.com/hjiang/scripts/blob/master/add-space-between-latin-and-cjk" target="_blank" rel="noopener">hjiang/scripts/add-space-between-latin-and-cjk</a></td><td>Python</td></tr></tbody></table><h2 id="谁在这样做？"><a href="#谁在这样做？" class="headerlink" title="谁在这样做？"></a>谁在这样做？</h2><table><thead><tr><th>网站</th><th>文案</th><th>UGC</th></tr></thead><tbody><tr><td><a href="http://www.apple.com/cn/" target="_blank" rel="noopener">Apple 中国</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.apple.com/hk/" target="_blank" rel="noopener">Apple 香港</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.apple.com/tw/" target="_blank" rel="noopener">Apple 台湾</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.microsoft.com/zh-cn/" target="_blank" rel="noopener">Microsoft 中国</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.microsoft.com/zh-hk/" target="_blank" rel="noopener">Microsoft 香港</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="http://www.microsoft.com/zh-tw/" target="_blank" rel="noopener">Microsoft 台湾</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></td><td>Yes</td><td>部分用户达成</td></tr><tr><td><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a></td><td>Yes</td><td>Yes</td></tr><tr><td><a href="https://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a></td><td>Yes</td><td>部分用户达成</td></tr><tr><td><a href="http://apple4us.com/" target="_blank" rel="noopener">Apple4us</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://www.wandoujia.com/" target="_blank" rel="noopener">豌豆荚</a></td><td>Yes</td><td>N/A</td></tr><tr><td><a href="https://ruby-china.org/" target="_blank" rel="noopener">Ruby China</a></td><td>Yes</td><td>标题达成</td></tr><tr><td><a href="https://phphub.org/" target="_blank" rel="noopener">PHPHub</a></td><td>Yes</td><td>标题达成</td></tr><tr><td><a href="http://sspai.com/" target="_blank" rel="noopener">少数派</a></td><td>Yes</td><td>N/A</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://grammar.about.com/od/punctuationandmechanics/a/Guidelines-For-Using-Capital-Letters.htm" target="_blank" rel="noopener">Guidelines for Using Capital Letters</a></li><li><a href="http://en.wikipedia.org/wiki/Letter_case" target="_blank" rel="noopener">Letter case - Wikipedia</a></li><li><a href="http://www.oxforddictionaries.com/words/punctuation" target="_blank" rel="noopener">Punctuation - Oxford Dictionaries</a></li><li><a href="https://owl.english.purdue.edu/owl/section/1/6/" target="_blank" rel="noopener">Punctuation - The Purdue OWL</a></li><li><a href="http://www.wikihow.com/Use-English-Punctuation-Correctly" target="_blank" rel="noopener">How to Use English Punctuation Corrently - wikiHow</a></li><li><a href="https://zh.opensuse.org/index.php?title=Help:%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">格式 - openSUSE</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2" target="_blank" rel="noopener">全角和半角 - 维基百科</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%BC%95%E8%99%9F" target="_blank" rel="noopener">引号 - 维基百科</a></li><li><a href="http://zh.wikipedia.org/wiki/%E7%96%91%E5%95%8F%E9%A9%9A%E5%98%86%E8%99%9F" target="_blank" rel="noopener">疑问惊叹号 - 维基百科</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了下目前 GitHub 上流行的中文书写指南。
    
    </summary>
    
      <category term="杂项" scheme="https://craneyuan.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>删除单链表中的倒数第N个节点</title>
    <link href="https://craneyuan.github.io/2016/10/12/remove-the-nth-node-from-end-of-list/"/>
    <id>https://craneyuan.github.io/2016/10/12/remove-the-nth-node-from-end-of-list/</id>
    <published>2016-10-12T11:20:34.000Z</published>
    <updated>2019-03-03T14:47:01.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><p>如何删除单链表中的倒数第n个节点？</p><h2 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h2><p>先遍历一遍单链表，计算出单链表的长度，然后，从单链表头部删除指定的节点。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 删除单链表倒数第n个节点，常规解法.</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">//get length of list</span></span><span class="line">    ListNode p = head;</span><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><span class="line">        len++;</span><span class="line">        p = p.next;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">//if remove first node</span></span><span class="line">    <span class="keyword">int</span> fromStart = len - n + <span class="number">1</span>;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (fromStart == <span class="number">1</span>) &#123;</span><span class="line">        <span class="keyword">return</span> head.next;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">//remove non-first node</span></span><span class="line">    p = head;</span><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><span class="line">        i++;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (i == fromStart - <span class="number">1</span>) &#123;</span><span class="line">            p.next = p.next.next;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        p = p.next;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">return</span> head;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="一次遍历法"><a href="#一次遍历法" class="headerlink" title="一次遍历法"></a>一次遍历法</h2><p>使用快慢指针。快指针比慢指针提前n个单元。当快指针到达单链表尾部时，慢指针指向待删除节点的前节点。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 删除单链表倒数第n个节点，快慢指针法.</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    ListNode fast = head;</span><span class="line">    ListNode slow = head;</span><span class="line"></span><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><span class="line">        fast = fast.next;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">//if remove the first node</span></span><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><span class="line">        head = head.next;</span><span class="line">        <span class="keyword">return</span> head;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><span class="line">        fast = fast.next;</span><span class="line">        slow = slow.next;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    slow.next = slow.next.next;</span><span class="line">    <span class="keyword">return</span> head;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.com/articles/remove-nth-node-end-list/" target="_blank" rel="noopener">LeetCode-Remove Nth Node From End of List</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://craneyuan.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单链表反转问题</title>
    <link href="https://craneyuan.github.io/2016/10/10/reverse-the-single-linkedlist/"/>
    <id>https://craneyuan.github.io/2016/10/10/reverse-the-single-linkedlist/</id>
    <published>2016-10-10T12:12:02.000Z</published>
    <updated>2019-03-03T14:46:25.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><p>如何将单链表反转？</p><h2 id="单链表结构定义"><a href="#单链表结构定义" class="headerlink" title="单链表结构定义"></a>单链表结构定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><span class="line"><span class="comment"> * 单链表定义</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><span class="line">    <span class="keyword">public</span> ListNode next;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><span class="line">        val = x;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 单链表反转</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> head;</span><span class="line">    &#125;</span><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><span class="line">    ListNode current = head;</span><span class="line">    ListNode next = <span class="keyword">null</span>;</span><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><span class="line">        next = current.next;</span><span class="line">        current.next = prev;</span><span class="line">        prev = current;</span><span class="line">        current = next;</span><span class="line">    &#125;</span><span class="line">    head = prev;</span><span class="line">    <span class="keyword">return</span> head;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h2><p>如何将单链表在指定区间内进行反转？</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个问题是上面问题的一个变形，难度也加大了不少，主要的难点之处就在于对边界条件的检查。<br>实现思路，主要就是按照给定的区间得到需要整体反转的一个子链表然后进行反转，最后就是把链表按正确的顺序拼接在一起。</p><h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 单链表反转，反转指定区间内的节点</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><span class="line">    <span class="comment">// 合法性检测</span></span><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || m &gt;= n || m &lt; <span class="number">1</span> || n &lt; <span class="number">1</span>) &#123;</span><span class="line">        <span class="keyword">return</span> head;</span><span class="line">    &#125;</span><span class="line">    <span class="comment">/** 将链表按[m,n]区间分成三段</span></span><span class="line"><span class="comment">     *</span></span><span class="line"><span class="comment">     * first,second,third分别为每一段的头节点(注意，m=1也就是first与second相等的情况的处理)</span></span><span class="line"><span class="comment">     * first --&gt; firstTail</span></span><span class="line"><span class="comment">     * second</span></span><span class="line"><span class="comment">     * third</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    ListNode first = head;</span><span class="line">    ListNode firstTail = first;</span><span class="line">    ListNode second = first;</span><span class="line">    ListNode third = first;</span><span class="line">    ListNode current = first;</span><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><span class="line">        i++;</span><span class="line">        <span class="keyword">if</span> (i == m - <span class="number">1</span>) &#123;</span><span class="line">            firstTail = current;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">if</span> (i == m) &#123;</span><span class="line">            second = current;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><span class="line">            third = current.next;</span><span class="line">            <span class="keyword">break</span>;</span><span class="line">        &#125;</span><span class="line">        current = current.next;</span><span class="line">    &#125;</span><span class="line">    <span class="comment">// 进行中间second段的reverse</span></span><span class="line">    current = second;</span><span class="line">    ListNode prev = third;</span><span class="line">    ListNode next = <span class="keyword">null</span>;</span><span class="line">    <span class="keyword">while</span> (current != third) &#123;</span><span class="line">        next = current.next;</span><span class="line">        current.next = prev;</span><span class="line">        prev = current;</span><span class="line">        current = next;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><span class="line">        first = prev;</span><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><span class="line">        firstTail.next = prev;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> first;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">reverse-linked-list</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了单链表反转问题的解决方法，并对问题进行了扩展。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://craneyuan.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>去除已排序链表中的重复元素</title>
    <link href="https://craneyuan.github.io/2016/09/17/remove-sorted-linkedlist-duplicated-value/"/>
    <id>https://craneyuan.github.io/2016/09/17/remove-sorted-linkedlist-duplicated-value/</id>
    <published>2016-09-17T13:08:12.000Z</published>
    <updated>2019-03-03T14:47:20.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的单链表，去除单链表中的重复元素，只保留一个重复的元素，并且返回新的单链表。</p><p>例如：<br>给出1-&gt;1-&gt;2，你的函数调用之后必须返回1-&gt;2。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>一个已排序的单链表，例如1-&gt;1-&gt;2。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>返回1-&gt;2。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 单链表定义</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><span class="line">    <span class="keyword">public</span> ListNode next;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><span class="line">        val = x;</span><span class="line">    &#125;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><span class="line">    &#125;</span><span class="line">    ListNode cur, prev;</span><span class="line">    prev = head;</span><span class="line">    cur = head.next;</span><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">if</span> (cur.val == prev.val) &#123;</span><span class="line">            prev.next = cur.next;</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            prev = cur;</span><span class="line">        &#125;</span><span class="line">        cur = prev.next;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> head;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521870409/blog/xq0luba6e6xkj26wz6mc.gif" alt="算法演示"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>去除单链表中重复元素，不保留任何重复的元素。</p><p>例如：<br>1-&gt;1-&gt;2-&gt;3-&gt;3-&gt;4，返回2-&gt;4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicatesAll</span><span class="params">(ListNode head)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">return</span> head;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(Integer.MAX_VALUE); <span class="comment">// 头结点</span></span><span class="line">    dummy.next = head;</span><span class="line">    ListNode prev, cur;</span><span class="line">    prev = dummy;</span><span class="line">    cur = head;</span><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">boolean</span> duplicated = <span class="keyword">false</span>;</span><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val) &#123;</span><span class="line">            duplicated = <span class="keyword">true</span>;</span><span class="line">            cur = cur.next;</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">if</span> (duplicated) &#123; <span class="comment">// 删除重复的最后一个元素</span></span><span class="line">            cur = cur.next;</span><span class="line">            <span class="keyword">continue</span>;</span><span class="line">        &#125;</span><span class="line">        prev.next = cur;</span><span class="line">        prev = prev.next;</span><span class="line">        cur = cur.next;</span><span class="line">    &#125;</span><span class="line">    prev.next = cur;</span><span class="line">    <span class="keyword">return</span> dummy.next;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">remove-duplicates-from-sorted-list</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://craneyuan.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>去除已排序数组中的重复元素</title>
    <link href="https://craneyuan.github.io/2016/09/16/remove-sorted-array-duplicated-value/"/>
    <id>https://craneyuan.github.io/2016/09/16/remove-sorted-array-duplicated-value/</id>
    <published>2016-09-16T12:18:12.000Z</published>
    <updated>2019-03-03T14:47:08.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的数组，去除数组中的重复元素，只保留一个重复的元素，并且返回新的数组长度。</p><p>要求：<br>不要给数组分配额外的空间，你必须使用常量的内存大小进行原地操作。</p><p>例如：<br>给出数组A=[1,1,2]，你的函数调用之后必须返回长度length=2，并且A现在变成[1,2]。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>一个已排序的数组，例如[1,1,2]。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>返回数组新的长度，例如length=2。</p><h2 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h2><p>设置fast指针遍历数组，slow指针指向不重复元素的下一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) &#123;</span><span class="line">        <span class="keyword">return</span> nums.length;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">int</span> slow = <span class="number">1</span>;</span><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">1</span>; fast &lt; nums.length; fast++) &#123;</span><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow - <span class="number">1</span>]) &#123;</span><span class="line">            nums[slow++] = nums[fast];</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> slow;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>动画演示：</p><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521870522/blog/viq29qhdvdn6wux4u635.gif" alt="动画演示"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>去除已排序数组中的重复元素，保留指定位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicatesN</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> repeatN)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (nums.length &lt;= repeatN) &#123;</span><span class="line">        <span class="keyword">return</span> nums.length;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">int</span> index = repeatN;</span><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = repeatN; i &lt; nums.length; i++) &#123;</span><span class="line">        <span class="keyword">if</span> (nums[i] != nums[index - repeatN]) &#123;</span><span class="line">            nums[index++] = nums[i];</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> index;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">remove-duplicates-from-sorted-array</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="https://craneyuan.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结8一一基数排序</title>
    <link href="https://craneyuan.github.io/2016/09/05/the-sort-algorithm-of-radix-sort/"/>
    <id>https://craneyuan.github.io/2016/09/05/the-sort-algorithm-of-radix-sort/</id>
    <published>2016-09-05T13:25:32.000Z</published>
    <updated>2019-03-03T14:30:46.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>基数排序（英文：radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p></blockquote><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521870769/blog/tzz66ougy2grbcnbiluf.jpg" alt="基数排序过程"></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>然后，从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li></ul><p>基数排序的方式可以采用<strong><em>LSD</em></strong>（Least significant digital）或<strong><em>MSD</em></strong>（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><blockquote><p>注意本次演示采用LSD的方式实现</p></blockquote><h2 id="代码实现（java）"><a href="#代码实现（java）" class="headerlink" title="代码实现（java）"></a>代码实现（java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 基数排序的简单实现，目前只能排序正整数</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] nums) &#123;</span><span class="line">    <span class="keyword">int</span> BASE_NUM = <span class="number">10</span>; <span class="comment">// 整数基数</span></span><span class="line">    <span class="keyword">int</span> len = nums.length;</span><span class="line">    <span class="keyword">int</span>[] buffer = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><span class="line"></span><span class="line">    <span class="keyword">int</span> maxValue = nums[<span class="number">0</span>], exp = <span class="number">1</span>;</span><span class="line"></span><span class="line">    <span class="comment">// 找出nums数组中最大的数</span></span><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><span class="line">            maxValue = nums[i];</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">while</span> (maxValue / exp &gt; <span class="number">0</span>) &#123;</span><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[BASE_NUM];</span><span class="line"></span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><span class="line">            bucket[i] = <span class="number">0</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 从数的低位开始进行桶排序</span></span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><span class="line">            bucket[(nums[i] / exp) % BASE_NUM]++;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 按照当前位给nums排序</span></span><span class="line">        <span class="comment">// 确定各个数对应的大概位置buket[(nums[i] / exp) % BASE]的值</span></span><span class="line">        <span class="comment">// 即为新位置的下标</span></span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; BASE_NUM; i++) &#123;</span><span class="line">            bucket[i] += bucket[i - <span class="number">1</span>];</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 按当前位进行排序存入到新数组</span></span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><span class="line">            <span class="keyword">int</span> index = (nums[i] / exp) % BASE_NUM;</span><span class="line">            buffer[--bucket[(nums[i] / exp) % BASE_NUM]] = nums[i];</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><span class="line">            nums[i] = buffer[i];</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        exp *= BASE_NUM;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> nums;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zh.wikipedia.org/wiki/基数排序" target="_blank" rel="noopener">基数排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="https://craneyuan.github.io/tags/sort/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结7一一堆排序</title>
    <link href="https://craneyuan.github.io/2016/09/04/the-sort-algorithm-of-heap-sort/"/>
    <id>https://craneyuan.github.io/2016/09/04/the-sort-algorithm-of-heap-sort/</id>
    <published>2016-09-04T12:28:15.000Z</published>
    <updated>2019-03-03T14:28:08.160Z</updated>
    
    <content type="html"><![CDATA[<p>在了解堆排序之前，我们有必要清楚“什么是堆呢？”。</p><blockquote><p>堆（英文：heap）是计算机科学中一类特殊的数据结构的统称。<strong><em>堆通常是一个可以被看做一棵树的数组对象。</em></strong>在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p></blockquote><p>堆的逻辑定义：<br><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521870976/blog/aolnikhrecm3o25auqzb.png" alt="堆的逻辑定义"></p><p>堆的实现通过构造二叉堆（英语：binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。</p><ul><li>任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。</li><li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li></ul><p>将根节点最大的堆叫做<strong><em>最大堆</em></strong>或大根堆，根节点最小的堆叫做<strong><em>最小堆</em></strong>或小根堆。常见的堆有<strong><em>二叉堆</em></strong>、斐波那契堆等。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>堆排序（英语：Heap Sort）是指利用<strong><em>堆</em></strong>这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p></blockquote><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521870837/blog/uy5o9garsujnzr0mo4ie.gif" alt="堆排序演示动画"></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>堆排序的根本是进行一次堆的构建过程。</p><ul><li>得到当前序列的最小(大)的元素 </li><li>把这个元素和最后一个元素进行交换,这样当前的最小(大)的元素就放在了序列的最后,而原先的最后一个元素放到了序列的最前面 </li><li>这交换可能会破坏堆序列的性质(注意此时的序列是除去已经放在最后面的元素),因此需要对序列进行调整,使之满足于上面堆的性质</li><li>重复上面的过程,直到序列调整完毕为止</li></ul><h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><p>在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><h3 id="堆节点的访问"><a href="#堆节点的访问" class="headerlink" title="堆节点的访问"></a>堆节点的访问</h3><p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p><ul><li>父节点i的左子节点在位置(2*i+1);</li><li>父节点i的右子节点在位置(2*i+2);</li><li>子节点i的父节点在位置floor((i-1)/2);</li></ul><h2 id="代码实现（java）"><a href="#代码实现（java）" class="headerlink" title="代码实现（java）"></a>代码实现（java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 堆排序的简单实现</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> count = a.length;</span><span class="line"></span><span class="line">    <span class="comment">// first place a in max-heap order</span></span><span class="line">    heapify(a, count);</span><span class="line"></span><span class="line">    <span class="keyword">int</span> end = count - <span class="number">1</span>;</span><span class="line">    <span class="keyword">while</span> (end &gt; <span class="number">0</span>) &#123;</span><span class="line">        <span class="comment">// swap the root(maximum value) of the heap with the</span></span><span class="line">        <span class="comment">// last element of the heap</span></span><span class="line">        <span class="keyword">int</span> tmp = a[end];</span><span class="line">        a[end] = a[<span class="number">0</span>];</span><span class="line">        a[<span class="number">0</span>] = tmp;</span><span class="line">        <span class="comment">// put the heap back in max-heap order</span></span><span class="line">        siftDown(a, <span class="number">0</span>, end - <span class="number">1</span>);</span><span class="line">        <span class="comment">// decrement the size of the heap so that the previous</span></span><span class="line">        <span class="comment">// max value will stay in its proper place</span></span><span class="line">        end--;</span><span class="line">    &#125;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> count)</span> </span>&#123;</span><span class="line">    <span class="comment">// start is assigned the index in a of the last parent node</span></span><span class="line">    <span class="keyword">int</span> start = (count - <span class="number">2</span>) / <span class="number">2</span>; <span class="comment">// binary heap</span></span><span class="line"></span><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span>) &#123;</span><span class="line">        <span class="comment">// sift down the node at index start to the proper place</span></span><span class="line">        <span class="comment">// such that all nodes below the start index are in heap</span></span><span class="line">        <span class="comment">// order</span></span><span class="line">        siftDown(a, start, count - <span class="number">1</span>);</span><span class="line">        start--;</span><span class="line">    &#125;</span><span class="line">    <span class="comment">// after sifting down the root all nodes/elements are in heap order</span></span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><span class="line">    <span class="comment">// end represents the limit of how far down the heap to sift</span></span><span class="line">    <span class="keyword">int</span> root = start;</span><span class="line"></span><span class="line">    <span class="keyword">while</span> ((root * <span class="number">2</span> + <span class="number">1</span>) &lt;= end) &#123; <span class="comment">// While the root has at least one child</span></span><span class="line">        <span class="keyword">int</span> child = root * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// root*2+1 points to the left child</span></span><span class="line">        <span class="comment">// if the child has a sibling and the child's value is less than its</span></span><span class="line">        <span class="comment">// sibling's...</span></span><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= end &amp;&amp; a[child] &lt; a[child + <span class="number">1</span>]) &#123;</span><span class="line">            child = child + <span class="number">1</span>; <span class="comment">// ... then point to the right child instead</span></span><span class="line">        &#125;</span><span class="line">        <span class="keyword">if</span> (a[root] &lt; a[child]) &#123; <span class="comment">// out of max-heap order</span></span><span class="line">            <span class="keyword">int</span> tmp = a[root];</span><span class="line">            a[root] = a[child];</span><span class="line">            a[child] = tmp;</span><span class="line">            root = child; <span class="comment">// repeat to continue sifting down the child now</span></span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zh.wikipedia.org/wiki/堆_%28数据结构%29" target="_blank" rel="noopener">堆</a></li><li><a href="https://zh.wikipedia.org/wiki/堆排序" target="_blank" rel="noopener">堆排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="https://craneyuan.github.io/tags/sort/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结6一一快速排序</title>
    <link href="https://craneyuan.github.io/2016/09/03/the-sort-algorithm-of-quick-sort/"/>
    <id>https://craneyuan.github.io/2016/09/03/the-sort-algorithm-of-quick-sort/</id>
    <published>2016-09-03T13:06:22.000Z</published>
    <updated>2019-03-03T14:30:38.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>快速排序（英文：quick Sort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p></blockquote><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521871052/blog/dnwug2dzi4wanknfet31.gif" alt="快速排序演示动画1"></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>快速排序使用分治法（divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><p>步骤为：</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line">function quicksort(q)</span><span class="line">     var list less, pivotList, greater</span><span class="line">     if length(q) ≤ 1 &#123;</span><span class="line">         return q</span><span class="line">     &#125; else &#123;</span><span class="line">         select a pivot value pivot from q</span><span class="line">         for each x in q except the pivot element</span><span class="line">             if x &lt; pivot then add x to less</span><span class="line">             if x ≥ pivot then add x to greater</span><span class="line">         add pivot to pivotList</span><span class="line">         return concatenate(quicksort(less), pivotList, quicksort(greater))</span><span class="line">     &#125;</span></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521871088/blog/jcnonjpmuhgzscxjukci.png" alt="快速排序演示动画2"></p><h2 id="代码实现（java）"><a href="#代码实现（java）" class="headerlink" title="代码实现（java）"></a>代码实现（java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 快速排序，递归版</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">List&lt;E&gt; <span class="title">quickSort</span><span class="params">(List&lt;E&gt; arr)</span> </span>&#123;</span><span class="line">    <span class="keyword">if</span> (!arr.isEmpty()) &#123;</span><span class="line">        E pivot = arr.get(<span class="number">0</span>); <span class="comment">// This pivot can change to get faster results</span></span><span class="line"></span><span class="line">        List&lt;E&gt; less = <span class="keyword">new</span> LinkedList&lt;E&gt;();</span><span class="line">        List&lt;E&gt; pivotList = <span class="keyword">new</span> LinkedList&lt;E&gt;();</span><span class="line">        List&lt;E&gt; more = <span class="keyword">new</span> LinkedList&lt;E&gt;();</span><span class="line"></span><span class="line">        <span class="comment">// Partition</span></span><span class="line">        <span class="keyword">for</span> (E i : arr) &#123;</span><span class="line">            <span class="keyword">if</span> (i.compareTo(pivot) &lt; <span class="number">0</span>) &#123;</span><span class="line">                less.add(i);</span><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i.compareTo(pivot) &gt; <span class="number">0</span>) &#123;</span><span class="line">                more.add(i);</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                pivotList.add(i);</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// Recursively sort sublists</span></span><span class="line">        less = quickSort(less);</span><span class="line">        more = quickSort(more);</span><span class="line"></span><span class="line">        <span class="comment">// Concatenate results</span></span><span class="line">        less.addAll(pivotList);</span><span class="line">        less.addAll(more);</span><span class="line">        <span class="keyword">return</span> less;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> arr;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zh.wikipedia.org/wiki/快速排序" target="_blank" rel="noopener">快速排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="https://craneyuan.github.io/tags/sort/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结5一一希尔排序</title>
    <link href="https://craneyuan.github.io/2016/09/02/the-sort-algorithm-of-shell-sort/"/>
    <id>https://craneyuan.github.io/2016/09/02/the-sort-algorithm-of-shell-sort/</id>
    <published>2016-09-02T02:22:52.000Z</published>
    <updated>2019-03-03T14:14:44.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>希尔排序（英文：shell sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p></blockquote><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521871154/blog/hbg1dkhruwy1ia3f3adr.gif" alt="希尔排序演示动画1"></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><ul><li>选择步长</li><li>按照选择的步长对序列进行排序</li><li>缩短步长</li><li>返回步骤二继续排序，直到步长为1</li></ul><h2 id="步长序列"><a href="#步长序列" class="headerlink" title="步长序列"></a>步长序列</h2><p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p><p>Donald Shell最初建议步长选择为n/2并且对步长取半直到步长达到1。虽然这样取可以比O(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p><h2 id="常见的步长序列"><a href="#常见的步长序列" class="headerlink" title="常见的步长序列"></a>常见的步长序列</h2><p><img src="https://res.cloudinary.com/dvspi0fq0/image/upload/v1521871201/blog/qwkoxbuogg1nsjhntmjy.png" alt="常见的步长序列"></p><h2 id="代码实现（java）"><a href="#代码实现（java）" class="headerlink" title="代码实现（java）"></a>代码实现（java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 希尔排序</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = nums.length;</span><span class="line">    <span class="keyword">int</span> temp;</span><span class="line">    <span class="comment">// 选择步长</span></span><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><span class="line">        <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></span><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</span><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><span class="line">            temp = nums[i];</span><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp; j -= gap) &#123;</span><span class="line">                nums[j + gap] = nums[j];</span><span class="line">            &#125;</span><span class="line">            nums[j + gap] = temp;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zh.wikipedia.org/wiki/希尔排序" target="_blank" rel="noopener">希尔排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      如题。
    
    </summary>
    
      <category term="算法" scheme="https://craneyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="sort" scheme="https://craneyuan.github.io/tags/sort/"/>
    
      <category term="algorithm" scheme="https://craneyuan.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java中被搁置的“goto”保留字</title>
    <link href="https://craneyuan.github.io/2016/08/30/the-reserved-word-of-goto/"/>
    <id>https://craneyuan.github.io/2016/08/30/the-reserved-word-of-goto/</id>
    <published>2016-08-30T12:48:42.000Z</published>
    <updated>2019-03-03T14:59:25.651Z</updated>
    
    <content type="html"><![CDATA[<p>goto语句一直被人所诟病，说它使得代码结构复杂化，但是语言设计者们还是没有放弃goto这个功能强大的语句。Java以面向对象所著称也没能够放弃goto，而是把它当做保留字，但是并未在语言中得到正式使用。</p><p>然而，从Java的break和continue这两个关键字的身上，我们依然能够看出一些goto的影子。</p><p>下面是《Thinking In Java 4th》中关于“goto”的介绍：</p><blockquote><h3 id="臭名昭著的“goto”"><a href="#臭名昭著的“goto”" class="headerlink" title="臭名昭著的“goto”"></a>臭名昭著的“goto”</h3><p>goto 关键字很早就在程序设计语言中出现。事实上，goto 是汇编语言的程序控制结构的始祖：“若条件A，则跳到这里；否则跳到那里”。若阅读由几乎所有编译器生成的汇编代码，就会发现程序控制里包含了许多<br>跳转。然而，goto 是在源码的级别跳转的，所以招致了不好的声誉。若程序总是从一个地方跳到另一个地方，还有什么办法能识别代码的流程呢？随着Edsger Dijkstra 著名的“Goto 有害”论的问世，goto 便从此<br>失宠。</p></blockquote><p>事实上，真正的问题并不在于使用goto，而在于goto 的滥用。而且在一些少见的情况下，goto 是组织控制流程的最佳手段。</p><p>尽管goto 仍是Java 的一个保留字，但并未在语言中得到正式使用；Java 没有goto。<strong><em>然而，在break 和continue 这两个关键字的身上，我们仍然能看出一些goto 的影子。</em></strong>它并不属于一次跳转，而是中断循环语句的一种方法。之所以把它们纳入goto 问题中一起讨论，是由于它们使用了相同的机制：标签。</p><h2 id="Java中的标签"><a href="#Java中的标签" class="headerlink" title="Java中的标签"></a>Java中的标签</h2><p>“标签”是后面跟一个冒号的标识符，就象下面这样：<br><code>label1:</code></p><p><strong><em>对Java 来说，唯一用到标签的地方是在循环语句之前。</em></strong>进一步说，它实际需要紧靠在循环语句的前方——在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另<br>一个循环或者一个开关。这是由于break 和continue 关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span></pre></td><td class="code"><pre><span class="line">label1:</span><span class="line">外部循环&#123;</span><span class="line">内部循环&#123;</span><span class="line">//...</span><span class="line">break; //1</span><span class="line">//...</span><span class="line">continue; //2</span><span class="line">//...</span><span class="line">continue label1; //3</span><span class="line">//...</span><span class="line">break label1; //4</span><span class="line">&#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>在条件1 中，break 中断内部循环，并在外部循环结束。在条件2 中，continue 移回内部循环的起始处。但在条件3 中，continue label1 却同时中断内部循环以及外部循环，并移至label1 处。随后，它实际是继续循环，但却从外部循环开始。在条件4 中，break label1 也会中断所有循环，并回到label1 处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。</p><h2 id="代码测试（java）"><a href="#代码测试（java）" class="headerlink" title="代码测试（java）"></a>代码测试（java）</h2><blockquote><p>一下代码均已在jdk1.6版本中测试通过</p></blockquote><h3 id="break语句测试"><a href="#break语句测试" class="headerlink" title="break语句测试"></a>break语句测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span></pre></td><td class="code"><pre><span class="line">public static void testLabel()</span><span class="line">&#123;</span><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><span class="line">        System.out.println(&quot;L1----&quot;+i);</span><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><span class="line">            if (j == 2) &#123;</span><span class="line">                break;</span><span class="line">            &#125;</span><span class="line">            System.out.println(&quot;--------L2---&quot;+j);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span></pre></td><td class="code"><pre><span class="line">L1----0</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span><span class="line">L1----1</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span></pre></td></tr></table></figure><p>这个代码中break直接中断内部的for循环。</p><h3 id="break-label语句测试"><a href="#break-label语句测试" class="headerlink" title="break+label语句测试"></a>break+label语句测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span></pre></td><td class="code"><pre><span class="line">public static void testLabel3()</span><span class="line">&#123;</span><span class="line">label1:</span><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><span class="line">        System.out.println(&quot;L1----&quot;+i);</span><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><span class="line">            if (j == 2) &#123;</span><span class="line">                break label1;</span><span class="line">            &#125;</span><span class="line">            System.out.println(&quot;--------L2---&quot;+j);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span></pre></td><td class="code"><pre><span class="line">L1----0</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span></pre></td></tr></table></figure><p>在这个代码中break中断标签label1处的外部for循环。</p><h3 id="continue语句测试"><a href="#continue语句测试" class="headerlink" title="continue语句测试"></a>continue语句测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span></pre></td><td class="code"><pre><span class="line">public static void testLabel2() &#123;</span><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><span class="line">System.out.println(&quot;L1----&quot;+i);</span><span class="line">for (int j = 0; j &lt; 4; j++) &#123;</span><span class="line">if (j == 2) &#123;</span><span class="line">continue;</span><span class="line">&#125;</span><span class="line">System.out.println(&quot;--------L2---&quot;+j);</span><span class="line">&#125;</span><span class="line">&#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span></pre></td><td class="code"><pre><span class="line">L1----0</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span><span class="line">--------L2---3</span><span class="line">L1----1</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span><span class="line">--------L2---3</span></pre></td></tr></table></figure><p>在这个代码中continue中断掉内部的for循环后继续执行内部for循环。</p><h3 id="continue-label语句测试"><a href="#continue-label语句测试" class="headerlink" title="continue+label语句测试"></a>continue+label语句测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span></pre></td><td class="code"><pre><span class="line">public static void testLabel4()</span><span class="line">&#123;</span><span class="line">label1:</span><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><span class="line">        System.out.println(&quot;L1----&quot;+i);</span><span class="line">        for (int j = 0; j &lt; 4; j++) &#123;</span><span class="line">            if (j == 2) &#123;</span><span class="line">                continue label1;</span><span class="line">            &#125;</span><span class="line">            System.out.println(&quot;--------L2---&quot;+j);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span></pre></td><td class="code"><pre><span class="line">L1----0</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span><span class="line">L1----1</span><span class="line">--------L2---0</span><span class="line">--------L2---1</span></pre></td></tr></table></figure><p>在这个代码中continue中断掉内部的for循环后继续执行跳到标签label1处的外部for循环，继续执行。</p>]]></content>
    
    <summary type="html">
    
      Java 中有「goto」吗？如果不了解可以看看本篇文章。
    
    </summary>
    
      <category term="Java平台" scheme="https://craneyuan.github.io/categories/Java%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="java" scheme="https://craneyuan.github.io/tags/java/"/>
    
  </entry>
  
</feed>
